#2017杭电多校第一场

[Gym 链接](https://codeforces.com/gym/102253)

hdu6033-6044

## A. Add More Zero

每次询问给定一个$n$，要求输出$2^n-1$的十进制位数减一

直接输出$(int)(n*log10(2))$即可

## B. Balala Power!

'a'-'z'26个小写字母个代表0-25这些数中的一个（互不相同），你有$n$个只含小写字母的字符串，你要安排'a'-'z'每个字母代表的数使得这些字符串代表的26进制数的总和最大且不含前导0

可以将26个字母每个字母的出现次数统计出来（出现次数可以用高精度26进制数来存储，然后直接对vector排序就好了）需要注意的是前导0需要单独处理，复杂度$O(T26n\log(26))$

## C. Colorful Tree

有一个n个结点的树，每个结点有颜色，定义路径的权值为路径上的不同颜色数量，求所有路径的权值和

反向考虑，对于每一种颜色考虑哪些路径这个颜色没有贡献，显然要求出不含这个颜色的连通块大小，那么树型dp即可，需要注意本题不能每个节点开map来存储，，否则会TLE,需要在dfs的过程中先行存储dfs之前的信息再做修改，这样所有颜色信息可以用一个数组来存储，复杂度$O(Tn)$

## F. Function

给你两个长度分别为n, m的数组a, b, a是0-n-1的一个排列, b是0-m-1的一个排列，你要求一个函数$f$, 使得$f(i) = b_{f(a_i)}$, 问你有多少种这样的$f$

首先$i->a[i]$建边，那么a一定是若干个环（可能有自环），同理b也是，找一找规律可以看出对于a中的一个环长为$x$的环，它的每个点的值必须是b上的一个环长为$y$的值,且$y$是$x$的因子，对于该环$x$方案数加上$y$，然后每个环之间方案数乘起来就好了，复杂度$O(Tn)$(看看代码想一想为什么，保证没有快速幂的那个$\log$)

## H. Hints of sd0061

你有1e7个数（由数据生成器生成），$m$次询问$b_{1..m}$，每次询问第$b_i+1$小的是哪个，其中$m\le100$,且保证$b_i+b_j\le b_k\ if\ b_i\neq b_j,b_i\lt b_k, b_j \lt b_k $

首先注意到$b$的限制，这保证了不同的$b$至多只有$\log(1e7)$这么多个（斐波那契数列），然后考虑库函数$nth\_element$,对询问进行从大到小处理，可以有效降低复杂度，复杂度$O(Tn)$

## I. I curse myself

给你一颗$n$个点$m$条边仙人掌，定义$V(k)$为该仙人掌的第$k$小生成树的权值(若生成树数量小于$k$则为0)，求$$\sum\limits_{k=1}^{k=K}kV(k)$$, $2\le n\le 1000, n-1\le m\le2n-3, 1\le K\le1e5$

首先仙人掌的最小生成树是每一个环去掉一条边，问题变成了有若干个集合，每个集合取一个数求前$K$大的和分别是啥，这是一个经典问题（...我怎么不知道），可以证明单组样例的复杂度为$O(mK)$，考虑如下合并算法:

合并两个集合(数组)A, B, 将A从大到小排列，向大根堆中加入$A[0]+B[j]$, 然后每次取出一个数$A[i]+B[j]$, 向堆中加入$A[i+1]+B[j]$,直到堆空或者取了$K$个为止，复杂度为$O(K\log(B.size))$, 可以让每次合并是$B$是新找到的环，那么总复杂度为$O(K\sum\log c_i), c_i$为环长，然后经过数学推导可得出复杂度为$O(mK)$, ps:如果合并时让$B$是之前已合并的集合那么复杂度就是$O(mK\log(K))$了，会TLE

## K. KazaQ's socks

$n$双袜子，一开始每双都是干净的，每天早上会选一双编号最小的干净的穿，若是有一天晚上发现脏袜子数量等于$n-1$则会洗了这些袜子，第二天晾干，第三天早上可用，给定$k$，问第$k$天穿的袜子编号

打表发现规律是$1,2,3,....,n$然后$1,2,3...,n-2,n-1,1,2,3....n-2,n$开始循环，循环节长度为$2*(n-1)$,直接求即可

## L. Limited Permutation

你有一个1-n的排列p, 有两个长为n的数组l, r,满足$\min\limits_{j = L}^Rp_j=p_i\ iff\ l_i\le L\le i\le R\le r_i$,求满足条件的排列$p$的数量$1\le n\le 1e6$

分析一下条件，意为$p_i$是$p_{l_i},p_{l_i+1},...p_{r_i}$这些数中最小值且$p_i\gt p_{l_i-1}, p_i\gt p_{r_i+1}$

考虑dfs(l ,r), 意为l到r放1 ~ r-l+1的排列方案数，首先这些数中一定有且仅有一个数$i$满足$l_i=l, r_i=r$(若没有或有多个则无解)，表示这些数中的最小值，然后它将$(l, r)$划分为两个区间$(l, i-1)$和$(i+1, r)$, 方案数要乘上$C(r-l, i-l)$,需要注意无解情况的判断，复杂度$O(Tn\log(n))$

